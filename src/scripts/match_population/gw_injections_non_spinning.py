import bilby
import deepdish
import numpy as np
import pickle
import pycbc
import pycbc.psd
import pycbc.types
import pycbc.waveform

delta_f = 1
duration = 100
minimum_frequency = 20
reference_frequency = 50  # Most sensitive frequency
maximum_frequency = 1024
sampling_frequency = 2048

def psd_gen(det):
    """Reading the PSD files for the detectors"""

    if det == 'H1':
        psd = pycbc.psd.read.from_txt('git_overlap/src/psds/O3-H1-C01_CLEAN_SUB60HZ-1251752040.0_sensitivity_strain_asd.txt', sampling_frequency, delta_f, minimum_frequency, is_asd_file=True)
    if det == 'L1':
        psd = pycbc.psd.read.from_txt('git_overlap/src/psds/O3-L1-C01_CLEAN_SUB60HZ-1240573680.0_sensitivity_strain_asd.txt', sampling_frequency, delta_f, minimum_frequency, is_asd_file=True)
    if det == 'V1':
        psd = pycbc.psd.read.from_txt('git_overlap/src/psds/O3-V1_sensitivity_strain_asd.txt', sampling_frequency, delta_f, minimum_frequency, is_asd_file=True)

    return psd

# Selecting SNRs > 8

def snr(injection_parameters):
    """Evaluates the matched filter signal-to-noise ratio (through PyCBC) for the set of waveforms generated by the injection parameters"""

    mass_1, mass_2, a_1, a_2, luminosity_distance, ra, dec, psi, incl, phase, geocent_time = injection_parameters['mass_1'], injection_parameters['mass_2'], injection_parameters['a_1'], injection_parameters['a_2'], injection_parameters['luminosity_distance'], injection_parameters['ra'], injection_parameters['dec'], injection_parameters['psi'], injection_parameters['incl'], injection_parameters['phase'], injection_parameters['geocent_time'] 

    hp, hc = pycbc.waveform.get_fd_waveform(approximant = 'IMRPhenomPv2', mass1 = mass_1, mass2 = mass_2, distance = luminosity_distance, spin1x = a_1, spin2x = a_2, 
                                            inclination = incl, coa_phase = phase, delta_f = delta_f, f_lower = minimum_frequency, f_final = maximum_frequency)    # Generate waveform 
     
    snrs = dict() 
    for det in ['H1', 'L1', 'V1']:

        det_obj = pycbc.detector.Detector(det)   # Loading the detector

        Fp, Fc = det_obj.antenna_pattern(ra, dec, psi, geocent_time)   # Antenna Patterns
        h = Fp*hp + Fc*hc   # h = F+*h+ + Fx*hx

        snrs[det] = pycbc.filter.matchedfilter.sigma(h, psd = psd_gen(det), low_frequency_cutoff = minimum_frequency, high_frequency_cutoff = maximum_frequency)   # Matched Filter SNR
    
    return np.sqrt(snrs['H1']**2+snrs['L1']**2+snrs['V1']**2)
    
injection = dict(deepdish.io.load('git_overlap/src/output/injections/injections.hdf5')['injections'])

for key, val in injection.items():
    exec(key + '=val')
mchirp = (mass_1 * mass_2) ** (3 / 5) / (mass_1 + mass_2) ** (1 / 5)

num_points = int(len(mchirp) / 2)
idxs = np.random.choice(len(mchirp), size=(num_points, 2), replace=False)

unique_idxs, counts = np.unique(idxs[:, 0], return_counts=True)
mask = counts == 1
filtered_idxs = idxs[mask]

delta_tc = np.clip(np.random.normal(0, 1, len(filtered_idxs)), -2, 2)

for i, idx in enumerate(filtered_idxs):
    mchirp_ratio = mchirp[idx[1]] / mchirp[idx[0]]

    if 0.5 <= mchirp_ratio <= 2:

        injection_parameters_a = {}
        injection_parameters_b = {}
        
        for key, val in injection.items():
            injection_parameters_a[key] = val[idx[0]]
            injection_parameters_b[key] = val[idx[1]]

        injection_parameters_a['a_1'], injection_parameters_a['a_2'] = 0, 0   #Non-Spinning
        injection_parameters_b['a_1'], injection_parameters_b['a_2'] = 0, 0   #Non-Spinning
        injection_parameters_b['geocent_time'] += delta_tc[i]
        start_time = injection_parameters_a['geocent_time'] - duration + 2

        injection_parameters_a['snr_det'] = snr(injection_parameters_a)
        injection_parameters_b['snr_det'] = snr(injection_parameters_b)
        
        if 0.5 <= injection_parameters_b['snr_det']/injection_parameters_a['snr_det'] <= 2 and injection_parameters_a['snr_det'] > 8 and injection_parameters_b['snr_det'] > 8:

            waveform_generator_a = bilby.gw.WaveformGenerator(
                duration=duration, sampling_frequency=sampling_frequency, start_time=start_time,
                frequency_domain_source_model=bilby.gw.source.lal_binary_black_hole,
                waveform_arguments={'waveform_approximant': 'IMRPhenomPv2', 'reference_frequency': reference_frequency,
                                    'minimum_frequency': minimum_frequency}
            )

            waveform_generator_b = bilby.gw.WaveformGenerator(
                duration=duration, sampling_frequency=sampling_frequency, start_time=start_time,
                frequency_domain_source_model=bilby.gw.source.lal_binary_black_hole,
                waveform_arguments={'waveform_approximant': 'IMRPhenomPv2', 'reference_frequency': reference_frequency,
                                    'minimum_frequency': minimum_frequency}
            )

            ifos, ifos_a, ifos_b = bilby.gw.detector.InterferometerList(['H1', 'L1', 'V1']), bilby.gw.detector.InterferometerList(['H1', 'L1', 'V1']), bilby.gw.detector.InterferometerList(['H1', 'L1', 'V1'])

            for det in [ifos, ifos_a, ifos_b]:
                for ifo in det:
                    ifo.minimum_frequency = minimum_frequency
                    ifo.maximum_frequency = sampling_frequency / 2
                det.set_strain_data_from_zero_noise(sampling_frequency=sampling_frequency, duration=duration,
                                                    start_time=start_time)

            ifos_a.inject_signal(waveform_generator=waveform_generator_a, parameters=injection_parameters_a)
            with open('git_overlap/src/output/match_population/match_population_non_spinning/injections/GW Waveform A Meta Data %s.pkl'%(i+1), 'wb') as file:
                pickle.dump(ifos_a.meta_data, file)

            ifos_b.inject_signal(waveform_generator=waveform_generator_b, parameters=injection_parameters_b)
            with open('git_overlap/src/output/match_population/match_population_non_spinning/injections/GW Waveform B Meta Data %s.pkl'%(i+1), 'wb') as file:
                pickle.dump(ifos_b.meta_data, file)